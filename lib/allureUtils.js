import { writeFileSync, mkdirSync, existsSync, readFileSync } from 'fs';
import { join } from 'path';
import { glob } from 'glob';

/**
 * Adds AI response as attachment to existing Allure test results
 * @param {string} response - AI response content
 * @param {string} originalPrompt - original error prompt
 * @param {Object} config - AI configuration
 * @param {string} testName - name of the test to attach to
 */
async function addAllureAttachmentToTest(response, originalPrompt, config, testName) {
  if (!config.allure_integration) {
    return;
  }

  try {
    const allureDir = config.allure_results_dir || 'allure-results';
    
    if (!existsSync(allureDir)) {
      console.log(`‚ö†Ô∏è  Allure results directory not found: ${allureDir}`);
      return;
    }

    // –ò—â–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã —Ç–µ—Å—Ç–æ–≤
    const testResultFiles = await glob(join(allureDir, '*-result.json'));
    
    if (testResultFiles.length === 0) {
      console.log(`‚ö†Ô∏è  No existing test results found in ${allureDir}`);
      return;
    }

    // –ù–∞—Ö–æ–¥–∏–º –ø–æ–¥—Ö–æ–¥—è—â–∏–π —Ç–µ—Å—Ç –ø–æ –∏–º–µ–Ω–∏ –∏–ª–∏ –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–π
    let targetTestFile = testResultFiles[testResultFiles.length - 1];
    
    if (testName) {
      const matchingTest = testResultFiles.find(file => {
        try {
          const content = readFileSync(file, 'utf8');
          const testResult = JSON.parse(content);
          return testResult.name && testResult.name.includes(testName);
        } catch {
          return false;
        }
      });
      
      if (matchingTest) {
        targetTestFile = matchingTest;
      }
    }

    // –ß–∏—Ç–∞–µ–º —Å—É—â–µ—Å—Ç–≤—É—é—â–∏–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
    const testContent = readFileSync(targetTestFile, 'utf8');
    const testResult = JSON.parse(testContent);

    // –°–æ–∑–¥–∞–µ–º —É–Ω–∏–∫–∞–ª—å–Ω—ã–π ID –¥–ª—è –∞—Ç—Ç–∞—á–º–µ–Ω—Ç–∞
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const attachmentId = `ai-debug-${timestamp}`;
    
    // –°–æ–∑–¥–∞–µ–º Markdown —Ñ–∞–π–ª —Å –æ—Ç–≤–µ—Ç–æ–º –ò–ò
    let markdownContent = `# ü§ñ AI Debug Analysis\n\n`;
    markdownContent += `**Generated:** ${new Date().toLocaleString('ru-RU')}\n`;
    markdownContent += `**Model:** ${config.model}\n`;
    markdownContent += `**Test:** ${testResult.name || 'Unknown'}\n\n`;
    markdownContent += `## üîç Detected Error\n\n`;
    markdownContent += `\`\`\`\n${originalPrompt}\n\`\`\`\n\n`;
    markdownContent += `## üí° AI Recommendations\n\n`;
    markdownContent += `${response}\n\n`;
    markdownContent += `---\n*Generated by playwright-ai-auto-debug*`;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º Markdown —Ñ–∞–π–ª
    const attachmentPath = join(allureDir, `${attachmentId}.md`);
    writeFileSync(attachmentPath, markdownContent, 'utf8');

    // –î–æ–±–∞–≤–ª—è–µ–º –∞—Ç—Ç–∞—á–º–µ–Ω—Ç –∫ —Å—É—â–µ—Å—Ç–≤—É—é—â–µ–º—É —Ç–µ—Å—Ç—É
    if (!testResult.attachments) {
      testResult.attachments = [];
    }

    testResult.attachments.push({
      name: 'ü§ñ AI Debug Analysis',
      source: `${attachmentId}.md`,
      type: 'text/markdown'
    });

    // –î–æ–±–∞–≤–ª—è–µ–º –º–µ—Ç–∫–∏ –¥–ª—è –ª—É—á—à–µ–π –∫–∞—Ç–µ–≥–æ—Ä–∏–∑–∞—Ü–∏–∏
    if (!testResult.labels) {
      testResult.labels = [];
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, –Ω–µ—Ç –ª–∏ —É–∂–µ –º–µ—Ç–∫–∏ AI Debug
    const hasAiLabel = testResult.labels.some(label => label.name === 'ai-debug');
    if (!hasAiLabel) {
      testResult.labels.push({
        name: 'ai-debug',
        value: 'enabled'
      });
    }

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –æ–±–Ω–æ–≤–ª–µ–Ω–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
    writeFileSync(targetTestFile, JSON.stringify(testResult, null, 2), 'utf8');

    console.log(`üìé AI response attached to test: ${testResult.name}`);
    console.log(`üìÑ Attachment file: ${attachmentPath}`);
    
  } catch (error) {
    console.error(`‚ùå Error adding Allure attachment: ${error.message}`);
  }
}

/**
 * Creates standalone Allure test result for AI analysis
 * @param {string} response - AI response content
 * @param {string} originalPrompt - original error prompt
 * @param {Object} config - AI configuration
 * @param {number} index - file index for naming
 */
function createStandaloneAllureResult(response, originalPrompt, config, index = 0) {
  if (!config.allure_integration) {
    return;
  }

  try {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
    const allureDir = config.allure_results_dir || 'allure-results';
    
    // –°–æ–∑–¥–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
    if (!existsSync(allureDir)) {
      mkdirSync(allureDir, { recursive: true });
    }

    const attachmentId = `ai-analysis-${timestamp}-${index.toString().padStart(3, '0')}`;
    
    // –°–æ–∑–¥–∞–µ–º Markdown —Ñ–∞–π–ª
    let markdownContent = `# ü§ñ AI Debug Analysis Report\n\n`;
    markdownContent += `**Analysis Date:** ${new Date().toLocaleString('ru-RU')}\n`;
    markdownContent += `**AI Model:** ${config.model}\n`;
    markdownContent += `**Server:** ${config.ai_server}\n`;
    markdownContent += `**File Index:** ${index + 1}\n\n`;
    markdownContent += `## üîç Original Error\n\n`;
    markdownContent += `\`\`\`\n${originalPrompt}\n\`\`\`\n\n`;
    markdownContent += `## üí° AI Solution\n\n`;
    markdownContent += `${response}\n\n`;
    markdownContent += `## üìã Recommendations\n\n`;
    markdownContent += `1. Review the suggested solution carefully\n`;
    markdownContent += `2. Test the fix in a development environment\n`;
    markdownContent += `3. Update test selectors if needed\n`;
    markdownContent += `4. Consider adding additional wait conditions\n\n`;
    markdownContent += `---\n*Generated automatically by playwright-ai-auto-debug*`;

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º Markdown —Ñ–∞–π–ª
    const attachmentPath = join(allureDir, `${attachmentId}.md`);
    writeFileSync(attachmentPath, markdownContent, 'utf8');

    // –°–æ–∑–¥–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞ –¥–ª—è Allure
    const testResult = {
      uuid: `ai-debug-${attachmentId}`,
      name: `ü§ñ AI Debug Analysis #${index + 1}`,
      fullName: `AI Debug Analysis for error file #${index + 1}`,
      status: 'passed',
      stage: 'finished',
      description: `Automatic AI analysis of Playwright test error with recommended solutions`,
      start: Date.now() - 2000,
      stop: Date.now(),
      attachments: [
        {
          name: 'ü§ñ AI Debug Report',
          source: `${attachmentId}.md`,
          type: 'text/markdown'
        }
      ],
      labels: [
        {
          name: 'suite',
          value: 'AI Debug'
        },
        {
          name: 'feature',
          value: 'Automatic Error Analysis'
        },
        {
          name: 'story',
          value: 'AI-Powered Debugging'
        },
        {
          name: 'severity',
          value: 'normal'
        },
        {
          name: 'ai-debug',
          value: 'enabled'
        }
      ],
      parameters: [
        {
          name: 'AI Model',
          value: config.model
        },
        {
          name: 'API Server',
          value: config.ai_server
        },
        {
          name: 'Error File Index',
          value: (index + 1).toString()
        }
      ]
    };

    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç —Ç–µ—Å—Ç–∞
    const testResultPath = join(allureDir, `${attachmentId}-result.json`);
    writeFileSync(testResultPath, JSON.stringify(testResult, null, 2), 'utf8');

    console.log(`üìä Standalone Allure result created: ${testResultPath}`);
    console.log(`üìé Attachment: ${attachmentPath}`);
    
  } catch (error) {
    console.error(`‚ùå Error creating standalone Allure result: ${error.message}`);
  }
}

export { addAllureAttachmentToTest, createStandaloneAllureResult }; 